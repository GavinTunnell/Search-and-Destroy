#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient

from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose


class TabletGoalToNav2(Node):
    def __init__(self):
        super().__init__('tablet_goal_to_nav2')

        # Subscribe to the tablet UI goal topic (unchanged)
        self.goal_sub = self.create_subscription(
            PoseStamped,
            '/tablet_goal',
            self.tablet_goal_callback,
            10
        )

        # Nav2 action client (default server name)
        self._action_client = ActionClient(
            self,
            NavigateToPose,
            'navigate_to_pose'
        )

        self._active_goal_handle = None
        self.get_logger().info(
            'TabletGoalToNav2 node started; listening on /tablet_goal'
        )

    def tablet_goal_callback(self, msg: PoseStamped):
        """
        Called whenever the tablet publishes a new goal.
        """
        self.get_logger().info(
            f'Received tablet goal: frame={msg.header.frame_id or "?"}, '
            f'x={msg.pose.position.x:.3f}, y={msg.pose.position.y:.3f}'
        )

        # Make sure Nav2 is up
        if not self._action_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().warn('navigate_to_pose action server not available yet')
            return

        # Cancel previous Nav2 goal if one is active
        if self._active_goal_handle is not None:
            self.get_logger().info('Cancelling previous Nav2 goal')
            try:
                self._active_goal_handle.cancel_goal_async()
            except Exception as e:
                self.get_logger().warn(f'Failed to cancel previous goal: {e}')

        # Build Nav2 NavigateToPose goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = msg

        # Stamp with current time (frame_id should already be 'map' from tablet)
        now = self.get_clock().now().to_msg()
        goal_msg.pose.header.stamp = now

        self.get_logger().info('Sending goal to Nav2 /navigate_to_pose')
        send_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        send_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """
        Called when Nav2 accepts/rejects the goal.
        """
        try:
            goal_handle = future.result()
        except Exception as e:
            self.get_logger().error(f'Error sending goal to Nav2: {e}')
            self._active_goal_handle = None
            return

        if not goal_handle.accepted:
            self.get_logger().warn('Nav2 goal rejected')
            self._active_goal_handle = None
            return

        self.get_logger().info('Nav2 goal accepted')
        self._active_goal_handle = goal_handle

        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

    def feedback_callback(self, feedback_msg):
        """
        Nav2 feedback (optional logging only).
        """
        fb = feedback_msg.feedback
        self.get_logger().debug(
            f'Nav2 feedback: distance_remaining={fb.distance_remaining:.3f}'
        )

    def result_callback(self, future):
        """
        Called when Nav2 finishes the goal.
        """
        try:
            result = future.result().result
            status = future.result().status
        except Exception as e:
            self.get_logger().error(f'Error getting Nav2 result: {e}')
            return

        self.get_logger().info(f'Nav2 goal finished with status={status}')
        self._active_goal_handle = None


def main(args=None):
    rclpy.init(args=args)
    node = TabletGoalToNav2()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
